{
  "repository": "nlothian/Vibe-Prolog",
  "issues": [
    {
      "number": 257,
      "title": "Parser does not register operators from use_module before parsing rest of file",
      "url": "https://github.com/nlothian/Vibe-Prolog/issues/257",
      "parent": null,
      "blocked_by": [],
      "blocking": [],
      "description": "## Problem\n\nWhen loading a Prolog file that uses `use_module` to import a library with custom operators, the parser fails because the operators are not registered before the rest of the file is parsed.\n\n### Example\n\nRunning:\n```bash\nuv run vibeprolog.py ./examples/not\\ yet\\ working/sudoku.pl\n```\n\nFails with:\n```\nError loading program: error(syntax_error(Unexpected end-of-input. Expected one of: ...\n```\n\nThe file contains:\n```prolog\n:- use_module(library('clpz')).\n\nsudoku([...]) :-\n    Vars = [...],\n    Vars in 1..9,   % <-- Parser fails here\n    ...\n```\n\nThe `in` operator is defined in `library/clpz.pl` (line 57: `op(700, xfx, in)`), but the parser does not know about it when it encounters `Vars in 1..9` because:\n\n1. The parser reads the entire file first\n2. Then directives like `use_module` are executed\n3. But by then, parsing has already failed because `in` was not a known operator\n\nThis is a **chicken-and-egg problem**: the module needs to be loaded to register its operators, but the file needs to be fully parsed before any directives can execute.\n\n## Solution\n\nImplement **incremental/two-pass parsing** that handles operator-defining directives before parsing the rest of the file.\n\n### Step 1: Create an operator pre-scanner\n\nCreate a utility function that scans Prolog source text for directives that define or import operators:\n\n- `:- op(Priority, Type, Name).` - Direct operator definitions\n- `:- use_module(library(Name)).` - Module imports that may export operators\n- `:- use_module(library(Name), ImportList).` - Selective module imports\n\nThis scanner should:\n- Use a minimal parser or regex to find these directives\n- Not fail on unknown operators in the rest of the file\n- Return a list of operator definitions and module names to load\n\n### Step 2: Modify the consultation process\n\nUpdate `PrologInterpreter.consult()` and `PrologInterpreter.consult_string()` to:\n\n1. **Pre-scan phase**: Before full parsing, scan the source for operator-defining directives\n2. **Process op/3 directives**: Register any `op/3` declarations found in the pre-scan\n3. **Load imported modules**: For each `use_module` directive found:\n   - Load the referenced module\n   - Extract operator declarations from the module's export list\n   - Register those operators in the parser's operator table\n4. **Full parse phase**: Now parse the complete file with the updated operator table\n5. **Execute directives**: Execute all directives as normal\n\n### Step 3: Handle module operator exports\n\nModules declare operators in their export list like this:\n```prolog\n:- module(clpz, [\n    op(700, xfx, in),\n    op(700, xfx, ins),\n    op(450, xfx, ..),\n    ...\n]).\n```\n\nThe module loading code needs to:\n- Parse the module declaration to extract `op/3` entries from the export list\n- Register these operators before the importing file continues parsing\n- Track which operators came from which module (for potential future unloading)\n\n### Step 4: Update the parser to support dynamic operator registration\n\nEnsure `PrologParser` can:\n- Accept new operators at runtime via a method like `register_operator(priority, type, name)`\n- Regenerate or update its grammar to include the new operator\n- The current implementation may already support this via the operator table - verify and document\n\n### Step 5: Handle recursive module loading\n\nWhen module A imports module B, and B imports module C:\n- Module C's operators must be available when parsing B\n- Module B's operators must be available when parsing A\n- Implement this recursively in the module loading process\n\n### Step 6: Handle circular imports gracefully\n\nIf module A imports B and B imports A:\n- Detect the cycle\n- Either raise an error or handle it gracefully (e.g., by tracking \"currently loading\" modules)\n\n## Files to Modify\n\n- `vibeprolog/interpreter.py` - Add pre-scanning and modify consultation process\n- `vibeprolog/parser.py` - Ensure dynamic operator registration works correctly\n- `vibeprolog/engine.py` - May need updates for module operator tracking\n\n## Test Coverage\n\nAdd comprehensive tests in a new test file `tests/test_module_operators.py`:\n\n### Basic operator import tests\n- Test that `use_module(library(clpz))` makes the `in` operator available\n- Test that `use_module(library(clpz))` makes the `..` operator available\n- Test that custom operators from modules work in expressions\n\n### Pre-scanning tests\n- Test that `op/3` directives at the top of a file are processed before parsing the rest\n- Test that multiple `op/3` directives are all processed\n- Test that `use_module` directives trigger operator loading\n\n### Order independence tests\n- Test that operators work regardless of where in the file they are used (after the directive)\n- Test that operators defined later in a file work in clauses that come after\n\n### Recursive module loading tests\n- Test module A importing B, where B defines operators used in A\n- Test multi-level imports (A imports B imports C, C has operators used in A)\n\n### Error handling tests\n- Test that using an operator before its `use_module` directive fails with a clear error\n- Test that circular imports are detected and handled\n- Test that importing a non-existent module gives a clear error\n\n### Integration tests\n- Test that `examples/not yet working/sudoku.pl` loads successfully after this fix\n- Test other CLP(Z) examples that use constraint operators\n\n## Documentation\n\nUpdate `docs/FEATURES.md`:\n- Mark module operator exports as fully implemented\n- Update the \"Imported operator discovery\" row to reflect the new capability\n- Add a note about the two-pass parsing approach if relevant\n\n## Acceptance Criteria\n\n- [ ] `sudoku.pl` loads without syntax errors\n- [ ] All CLP(Z) operators (`in`, `ins`, `..`, `#=`, `#<`, etc.) work when clpz is imported\n- [ ] Operators from any module are available after `use_module`\n- [ ] Clear error messages when operators are used before being defined/imported\n- [ ] All new tests pass\n- [ ] Existing tests continue to pass\n- [ ] FEATURES.md is updated\n",
      "comments": [],
      "labels": [
        {
          "name": "nac",
          "color": "f4e927",
          "description": "Nick's Autocoder used: https://github.com/nlothian/autocoder"
        },
        {
          "name": "amp",
          "color": "e18ccd",
          "description": ""
        }
      ],
      "milestones": [],
      "linked_branches": [
        {
          "name": "257-parser-does-not-register-operators-from-use_module-before-parsing-rest-of-file",
          "repository": "nlothian/Vibe-Prolog",
          "commit": "1e17d50a9181b74877dbc05b9b235d98510d903a"
        }
      ]
    },
    {
      "number": 252,
      "title": "Implement --builtin-conflict=shadow mode to allow modules to shadow built-in predicates",
      "url": "https://github.com/nlothian/Vibe-Prolog/issues/252",
      "parent": null,
      "blocked_by": [],
      "blocking": [],
      "description": "## Problem\n\nWhen a library module defines a predicate that is also a built-in (e.g., `length/2`), users may want the module version to take precedence within that module's namespace, rather than silently using the built-in.\n\nThis is the `shadow` mode for the `--builtin-conflict` flag introduced in #251.\n\n## Solution\n\nImplement the `shadow` mode for `--builtin-conflict`, which allows module-defined predicates to shadow built-in predicates within their module namespace.\n\n### Behavior\n\nWhen `--builtin-conflict=shadow` is set:\n- A module can define a predicate with the same name/arity as a built-in\n- Within that module, calls to the predicate use the module's definition\n- Outside the module (or with explicit `user:` qualification), the built-in is used\n- Module-qualified calls like `lists:length(X, Y)` use the module's definition\n\n### Example\n\n```prolog\n% In library(lists)\n:- module(lists, [length/2]).\n\nlength([], 0).\nlength([_|T], N) :- length(T, N1), N is N1 + 1.\n```\n\n```prolog\n% User code\n:- use_module(library(lists)).\n\n% This uses the lists module version of length/2\n?- lists:length([a,b,c], N).\nN = 3.\n\n% This uses the built-in version\n?- length([a,b,c], N).\nN = 3.\n```\n\n## Implementation Steps\n\n### 1. Update Module Data Structures\n\n- Extend the `Module` class to track predicates that shadow built-ins\n- Add a mechanism to store module-local predicate definitions separately from the global clause database\n- Ensure the module knows which of its predicates shadow built-ins\n\n### 2. Modify Clause Storage During Consult\n\n- When consulting a module with `builtin_conflict=shadow`:\n  - Check if the predicate being defined is a built-in\n  - If so, store the clause in the module's local predicate storage instead of raising an error\n  - Mark the predicate as \"shadows built-in\" in the module metadata\n\n### 3. Update Goal Resolution\n\n- Modify the engine's goal resolution to check for shadowed predicates:\n  - For module-qualified calls (`Module:Goal`): Check if `Module` has a shadowing definition, use it if present\n  - For unqualified calls within a module body: Check the defining module for shadows first\n  - For unqualified calls from user code: Use the built-in (unless imported with shadowing - see below)\n\n### 4. Handle Imports with Shadowing\n\n- When a module imports a predicate that shadows a built-in via `use_module/2`:\n  - Decide on semantics: Does the import bring in the shadow, or does the built-in take precedence?\n  - Document the chosen behavior clearly\n  - Suggested behavior: Explicit imports (`use_module(library(lists), [length/2])`) bring in the shadow; implicit imports use the built-in\n\n### 5. Update the CLI Flag Handler\n\n- Remove the \"not yet implemented\" error for `shadow` mode in `vibeprolog.py`\n- Ensure the mode is correctly passed through to the interpreter and engine\n\n### 6. Add Tests\n\nCreate comprehensive tests covering:\n\n- **Basic shadowing**:\n  - A module can define a predicate with the same name/arity as a built-in\n  - Module-qualified calls use the module's version\n  - Unqualified calls from user context use the built-in\n\n- **Shadowing within module bodies**:\n  - When a module's clause body calls a shadowed predicate, it uses the module's version\n  - Cross-module calls resolve correctly\n\n- **Import behavior**:\n  - Test explicit imports of shadowed predicates\n  - Test implicit imports (full module import)\n  - Verify the chosen semantics are consistent\n\n- **Interaction with other modes**:\n  - Verify `skip` mode still works correctly\n  - Verify `error` mode still works correctly\n\n- **Edge cases**:\n  - Module defines predicate, then built-in is called explicitly with `user:predicate`\n  - Nested module imports with shadowing\n  - Dynamic predicates that shadow built-ins\n\n- **Real-world usage**:\n  - Test with actual library modules that define common predicates (e.g., `library(lists)`)\n\n### 7. Update Documentation\n\n- Update `docs/FEATURES.md` to document the `shadow` mode\n- Remove any \"not implemented\" notes for this mode\n- Add examples showing shadowing behavior\n- Document the import semantics clearly\n- Update `docs/ARCHITECTURE.md` if the module system internals change significantly\n\n## Dependencies\n\n- Requires #251 to be implemented first (the `--builtin-conflict` flag infrastructure)\n\n## Acceptance Criteria\n\n- [ ] `--builtin-conflict=shadow` allows modules to define predicates that shadow built-ins\n- [ ] Module-qualified calls use the module's definition\n- [ ] Unqualified calls from user context use the built-in\n- [ ] Import behavior is well-defined and documented\n- [ ] All new code has comprehensive test coverage\n- [ ] `docs/FEATURES.md` is updated with the new functionality\n- [ ] `docs/ARCHITECTURE.md` is updated if module internals change\n",
      "comments": [],
      "labels": [],
      "milestones": [],
      "linked_branches": []
    },
    {
      "number": 7,
      "title": "Compatibility: Mirror SWI-Prolog examples",
      "url": "https://github.com/nlothian/Vibe-Prolog/issues/7",
      "parent": null,
      "blocked_by": [
        {
          "number": 75,
          "title": "Implement command-line argument support (argv)",
          "url": "https://github.com/nlothian/Vibe-Prolog/issues/75",
          "blocking_issue_status": "closed"
        }
      ],
      "blocking": [],
      "description": "## Overview\n\nThis task is about **validating that our Prolog interpreter behaves the same way as SWI-Prolog**, which is one of the most popular Prolog implementations. We want to ensure our syntax and behavior match what developers expect from widely-used Prolog systems.\n\n## Why This Matters\n\n- **Compatibility**: Users should be able to run standard Prolog examples on our interpreter\n- **Confidence**: Automated tests comparing our output to SWI-Prolog give us confidence we're implementing Prolog correctly\n- **Documentation**: This helps identify what features we're missing or where we deviate from standard behavior\n\n## Prerequisites\n\n1. **Install SWI-Prolog** on your system:\n   - Mac: `brew install swi-prolog`\n   - Linux: `apt-get install swi-prolog` or `yum install swi-prolog`\n   - Windows: Download from https://www.swi-prolog.org/Download.html\n\n2. **Verify installation**:\n   ```bash\n   swipl --version\n   ```\n\n3. **Understand our test structure** (see `AGENTS.md` for details):\n   - All tests go in `tests/` directory\n   - Test files are named `test_*.py`\n   - Use pytest framework with test classes\n   - Import with `from prolog import PrologInterpreter`\n\n## Step-by-Step Instructions\n\n### Step 1: Find Representative SWI-Prolog Examples\n\nLook for examples in these categories (prioritize ones testing features marked \u2705 in `FEATURES.md`):\n\n**Control Flow Examples:**\n- Conjunction (`,`), disjunction (`;`), if-then-else (`->`)\n- Negation (`\\+`), cut (`!`)\n- Backtracking behavior\n\n**Arithmetic Examples:**\n- Arithmetic evaluation (`is/2`)\n- Arithmetic comparison (`=:=`, `<`, `>`, etc.)\n- Complex expressions with operators (`+`, `-`, `*`, `/`, `mod`, `**`)\n\n**Data Structure Examples:**\n- List manipulation (`append/3`, `member/2`, `length/2`, `reverse/2`)\n- Compound terms (`functor/3`, `arg/3`, `=../2`)\n- Type testing (`var/1`, `atom/1`, `number/1`, etc.)\n\n**Good sources for examples:**\n- [SWI-Prolog documentation](https://www.swi-prolog.org/pldoc/man?section=builtin)\n- [Learn Prolog Now!](http://www.learnprolognow.org/)\n- SWI-Prolog's own test suite\n\n### Step 2: Test Examples in SWI-Prolog\n\nBefore porting, verify the example works in SWI-Prolog:\n\n```bash\n# Start SWI-Prolog\nswipl\n\n# Test a query\n?- append([1,2], [3,4], X).\nX = [1, 2, 3, 4].\n\n# Test with backtracking\n?- member(X, [1,2,3]).\nX = 1 ;\nX = 2 ;\nX = 3.\n```\n\n**Document the expected behavior** - write down:\n- What query you ran\n- What solutions you got\n- Whether it backtracks (provides multiple solutions)\n- Any error messages\n\n### Step 3: Create Test Cases\n\nCreate a new test file or add to an existing one. Follow this pattern:\n\n```python\n\"\"\"Tests comparing behavior to SWI-Prolog examples.\"\"\"\n\nimport pytest\nfrom prolog import PrologInterpreter\n\n\nclass TestSWIPrologControlFlow:\n    \"\"\"Tests based on SWI-Prolog control flow examples.\"\"\"\n    \n    def test_conjunction_example(self):\n        \"\"\"\n        SWI-Prolog example from: [URL or book reference]\n        Query: X = 1, Y = 2.\n        Expected: X = 1, Y = 2\n        \"\"\"\n        prolog = PrologInterpreter()\n        result = prolog.query_once(\"X = 1, Y = 2\")\n        assert result is not None\n        assert result['X'] == 1\n        assert result['Y'] == 2\n    \n    def test_backtracking_example(self):\n        \"\"\"\n        SWI-Prolog example: member/2 with backtracking\n        Query: member(X, [a,b,c]).\n        Expected: X = a ; X = b ; X = c\n        \"\"\"\n        prolog = PrologInterpreter()\n        results = list(prolog.query(\"member(X, [a, b, c])\"))\n        assert len(results) == 3\n        assert results[0]['X'] == 'a'\n        assert results[1]['X'] == 'b'\n        assert results[2]['X'] == 'c'\n\n\nclass TestSWIPrologArithmetic:\n    \"\"\"Tests based on SWI-Prolog arithmetic examples.\"\"\"\n    \n    def test_arithmetic_expression(self):\n        \"\"\"\n        SWI-Prolog example: X is 2 + 3 * 4.\n        Expected: X = 14 (multiplication before addition)\n        \"\"\"\n        prolog = PrologInterpreter()\n        result = prolog.query_once(\"X is 2 + 3 * 4\")\n        assert result is not None\n        assert result['X'] == 14\n```\n\n### Step 4: Run Tests and Compare\n\n```bash\n# Run your new tests\nuv run pytest tests/test_swi_examples.py -v\n\n# Run all tests to make sure nothing broke\nuv run pytest\n```\n\n### Step 5: Document Incompatibilities\n\nIf you find differences between our interpreter and SWI-Prolog:\n\n1. **Add a comment in your test** explaining the deviation:\n   ```python\n   @pytest.mark.skip(reason=\"Feature not implemented: read/1\")\n   def test_read_term(self):\n       \"\"\"SWI-Prolog supports read/1 but we don't implement it yet.\"\"\"\n       pass\n   ```\n\n2. **Update FEATURES.md** if you discover missing features or incorrect implementations\n\n3. **Create follow-up issues** for significant problems:\n   ```bash\n   gh issue create --title \"Fix: append/3 fails with improper lists\" \\\n       --body \"Found in SWI-Prolog compatibility testing. Expected behavior: ...\"\n   ```\n\n## Example Test File Structure\n\nLook at existing test files for patterns to follow:\n- `tests/test_iso_core.py` - Well-organized ISO standard tests\n- `tests/test_builtins.py` - Tests for built-in predicates\n- `tests/test_arithmetic.py` - Arithmetic operation tests\n\n## Testing Checklist\n\n- [ ] Selected 15-25 representative examples from SWI-Prolog\n- [ ] Verified each example works in SWI-Prolog (document expected output)\n- [ ] Created test file(s) in `tests/` directory following pytest conventions\n- [ ] Each test has a docstring explaining the SWI-Prolog source\n- [ ] Tests cover control flow, arithmetic, and data structures\n- [ ] All tests pass (or marked with `@pytest.mark.skip` with reason)\n- [ ] Documented any incompatibilities in test comments\n- [ ] Updated `FEATURES.md` if you found missing/incorrect features\n- [ ] Created follow-up issues for bugs or missing features found\n\n## Questions?\n\n- Review existing test files in `tests/` directory for examples\n- Check `AGENTS.md` for development workflow guidelines\n- Check `FEATURES.md` to see what's already implemented\n- Ask for help if you're unsure about expected behavior\n\n## Success Criteria\n\n- At least 15 new tests comparing our behavior to SWI-Prolog\n- Tests cover multiple categories (control, arithmetic, data structures)\n- Any incompatibilities are documented\n- All tests either pass or are marked with clear skip reasons\n- `docs/FEATURES.md` updated if new gaps discovered",
      "comments": [],
      "labels": [
        {
          "name": "nac",
          "color": "f4e927",
          "description": "Nick's Autocoder used: https://github.com/nlothian/autocoder"
        },
        {
          "name": "kilocode",
          "color": "045836",
          "description": ""
        },
        {
          "name": "amp",
          "color": "e18ccd",
          "description": ""
        }
      ],
      "milestones": [],
      "linked_branches": [
        {
          "name": "7-compatibility-mirror-swi-prolog-examples",
          "repository": "nlothian/Vibe-Prolog",
          "commit": "1e17d50a9181b74877dbc05b9b235d98510d903a"
        }
      ]
    }
  ]
}